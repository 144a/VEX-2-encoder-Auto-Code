#pragma config(Sensor, dgtl1,  backLeft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  backRight,      sensorQuadEncoder)
#pragma config(Motor,  port2,           frontRightMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           backRightMotor, tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           frontLeftMotor, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           backLeftMotor, tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float WHEELDIAM = 4;
// DEGRAT NEEDS TO BE TESTED AND CHANGED FOR EACH INDIVIDUAL BOT!!!
const float DEGRAT = 2.3;
const int FAST = 127;
const int SLOW = 110;

// Sets Motors to 0
void ZeroMotors(){
	motor[frontRightMotor] = 0;
	motor[backRightMotor]  = 0;
	motor[frontLeftMotor] = 0;
  motor[backLeftMotor]  = 0;
}

// Sets Encoders to 0
void ZeroEncoders(){
	SensorValue[backLeft] = 0;
	SensorValue[backRight] = 0;
}


// Moves a specified number of inches
void moveForward(int dist){

	// tickgoal = (60 / ( pi * wheel diameter)) * dist
	float tickgoal = (360 / (3.1415926535 * WHEELDIAM)) * dist;

	// Zero out both encoders
	ZeroEncoders();

	// Sets all motors to 127
	motor[frontRightMotor] = FAST;
	motor[backRightMotor]  = FAST;
	motor[frontLeftMotor] = FAST;
  motor[backLeftMotor]  = FAST;

  // Checks to see whether the tick goal has been met on both encoders
	while(SensorValue[backRight] < tickgoal && SensorValue[backLeft] < tickgoal){
		if(SensorValue[backRight] == SensorValue[backLeft]){
			motor[frontRightMotor] = FAST;
			motor[backRightMotor]  = FAST;
			motor[frontLeftMotor] = FAST;
  		motor[backLeftMotor]  = FAST;
  	}
  	if(SensorValue[backRight] < SensorValue[backLeft]){
			motor[frontRightMotor] = FAST;
			motor[backRightMotor]  = FAST;
			motor[frontLeftMotor] = SLOW;
  		motor[backLeftMotor]  = SLOW;
  	}
  	if(SensorValue[backRight] > SensorValue[backLeft]){
			motor[frontRightMotor] = SLOW;
			motor[backRightMotor]  = SLOW;
			motor[frontLeftMotor] = FAST;
  		motor[backLeftMotor]  = FAST;
  	}
	}
	// Sets all motors to 0
	ZeroMotors();
}

// Turns right a given number of degrees
void turnRightDeg(int degrees){

	// tickgoal = num of degrees to move * tick to degree ratio
	float tickgoal = degrees * DEGRAT;

	// Zero out both encoders
	ZeroEncoders();

	// Sets all motors to 127
	motor[frontRightMotor] = FAST;
	motor[backRightMotor]  = FAST;
	motor[frontLeftMotor] = -1 * FAST;
  motor[backLeftMotor]  = -1 * FAST;

  // Checks to see whether the tick goal has been met on both encoders
	while(SensorValue[backRight] > -1 * tickgoal || SensorValue[backLeft] < tickgoal){
		if(SensorValue[backLeft] > tickgoal){
			motor[frontLeftMotor] = 0;
  		motor[backLeftMotor]  = 0;
  	}
  	if(SensorValue[backRight] < -1 * tickgoal){
			motor[frontRightMotor] = 0;
			motor[backRightMotor]  = 0;
  	}
	}
	// Sets all motors to 0
	ZeroMotors();
}


// Turns left a given number of degrees
void turnLeftDeg(int degrees){

	// tickgoal = num of degrees to move * tick to degree ratio
	float tickgoal = degrees * DEGRAT;

	// Zero out both encoders
	ZeroEncoders();

	// Sets all motors to 127
	motor[frontRightMotor] = -1 * FAST;
	motor[backRightMotor]  = -1 * FAST;
	motor[frontLeftMotor] = FAST;
  motor[backLeftMotor]  = FAST;

  // Checks to see whether the tick goal has been met on both encoders
	while(SensorValue[backRight] < tickgoal || SensorValue[backLeft] > -1 * tickgoal){
		if(SensorValue[backLeft] < -1 * tickgoal){
			motor[frontLeftMotor] = 0;
  		motor[backLeftMotor]  = 0;
  	}
  	if(SensorValue[backRight] > tickgoal){
			motor[frontRightMotor] = 0;
			motor[backRightMotor]  = 0;
  	}
	}
	// Sets all motors to 0
	ZeroMotors();
}

task main(){


}
